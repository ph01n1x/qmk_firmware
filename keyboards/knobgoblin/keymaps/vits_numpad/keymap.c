/* Copyright 2020 MrT1ddl3s
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include QMK_KEYBOARD_H

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {

    [0] = LAYOUT_ortho
    (
                  KC_PEQL, KC_PSLS, KC_PAST, KC_PMNS,
                  KC_P7,   KC_P8,   KC_P9,   KC_PPLS,
                  KC_P4,   KC_P5,   KC_P6,   KC_PPLS,
         KC_MPLY, KC_P1,   KC_P2,   KC_P3,   KC_PENT,
         KC_MUTE, TT(1),   KC_P0,   KC_PDOT, KC_PENT
    ),

	[1] = LAYOUT_ortho
    (
                  KC_NUM,  KC_TRNS, KC_TRNS,  KC_ESC,
                  KC_HOME, KC_TRNS, KC_PGUP,  KC_TRNS,
                  KC_END,  KC_UP,   KC_PGDN,  KC_TRNS,
         KC_TRNS, KC_LEFT, KC_DOWN, KC_RIGHT, KC_NO,
         KC_TRNS, KC_TRNS, KC_BSPC, KC_DEL,   KC_NO

    )            
};

uint32_t keyevent_timer = 0;

#ifdef ENCODER_ENABLE

// Handle the encoder rotation
bool encoder_update_user(uint8_t index, bool clockwise) 
{
    keyevent_timer = timer_read32();

    // Top encoder
    if (index == 0) 
    { 
        if (clockwise) 
        {
            tap_code(KC_MNXT);
        } 
        else 
        {
            tap_code(KC_MPRV);
        }
    }

    // Bottom encoder
    if (index == 1) 
    {
        if (clockwise) 
        {
            tap_code(KC_VOLU);
        } 
        else 
        {
            tap_code(KC_VOLD);
        }
    }

    // Disable keyboard level code.
    return false;
}

#endif

// Handle key events
bool process_record_user(uint16_t keycode, keyrecord_t *record) 
{
    keyevent_timer = timer_read32();
    return true;
}

#ifdef OLED_DRIVER_ENABLE

// Rotate screen for proper orentation
__attribute__((weak)) oled_rotation_t oled_init_user(oled_rotation_t rotation) { return OLED_ROTATION_270; }

uint32_t animation_timer = 0;
uint32_t frame_duration = 500;
uint8_t current_frame = 0;

// Animated goblin logo
static void render_logo(void) {
    static const char PROGMEM goblin[][128] = 
    {
        [0] = 
        {
        // 'Goblin1', 32x32px
        0x00, 0x7c, 0xc8, 0x90, 0x30, 0x20, 0x20, 0x10, 0x10, 0x18, 0x0c, 0x04, 0x02, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x02, 0x04, 0x0c, 0x18, 0x10, 0x10, 0x20, 0x20, 0x30, 0x90, 0xc8, 0x7c, 0x00, 
        0x00, 0x00, 0x00, 0x07, 0x09, 0x32, 0xe4, 0x00, 0x08, 0x10, 0xd0, 0xd0, 0xf0, 0xe0, 0x0c, 0x00, 
        0x00, 0x0c, 0xe0, 0xf0, 0xd0, 0xd0, 0x10, 0x08, 0x00, 0xe4, 0x32, 0x09, 0x07, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x08, 0xf8, 0x60, 0xe1, 0xc1, 0xcc, 0xca, 0xd8, 
        0xd8, 0xca, 0xcc, 0xc1, 0xe1, 0x60, 0xf8, 0x08, 0x0c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x18, 0x31, 0x63, 0xc7, 0x87, 
        0x87, 0xc7, 0x63, 0x31, 0x18, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        },
        [1] = 
        {
        // 'Goblin2', 32x32px
        0x00, 0x3e, 0x64, 0xc8, 0x98, 0x10, 0x10, 0x08, 0x08, 0x0c, 0x06, 0x02, 0x01, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x01, 0x02, 0x06, 0x0c, 0x08, 0x08, 0x10, 0x10, 0x98, 0xc8, 0x64, 0x3e, 0x00, 
        0x00, 0x00, 0x00, 0x03, 0x04, 0x19, 0xf2, 0x00, 0x04, 0x08, 0x68, 0xe8, 0xf8, 0x70, 0x06, 0x00, 
        0x00, 0x06, 0x70, 0xf8, 0xe8, 0x68, 0x08, 0x04, 0x00, 0xf2, 0x19, 0x04, 0x03, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x04, 0xfc, 0x70, 0xf0, 0xe0, 0xe6, 0xe5, 0xec, 
        0xec, 0xe5, 0xe6, 0xe0, 0xf0, 0x70, 0xfc, 0x04, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x18, 0x31, 0x63, 0xc7, 0x87, 
        0x87, 0xc7, 0x63, 0x31, 0x18, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        },
        [2] =
        {
        // 'Goblin3', 32x32px
        0x00, 0x3e, 0x64, 0xc8, 0x98, 0x10, 0x10, 0x08, 0x08, 0x0c, 0x06, 0x02, 0x01, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x01, 0x02, 0x06, 0x0c, 0x08, 0x08, 0x10, 0x10, 0x98, 0xc8, 0x64, 0x3e, 0x00, 
        0x00, 0x00, 0x00, 0x03, 0x04, 0x19, 0xf2, 0x00, 0x04, 0x08, 0x68, 0xe8, 0xf8, 0x70, 0x06, 0x00, 
        0x00, 0x06, 0x70, 0xf8, 0xe8, 0x68, 0x08, 0x04, 0x00, 0xf2, 0x19, 0x04, 0x03, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x04, 0xfc, 0xf0, 0xf0, 0xe0, 0xe6, 0xe5, 0xec, 
        0xec, 0xe5, 0xe6, 0xe0, 0xf0, 0xf0, 0xfc, 0x04, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1e, 0x31, 0x63, 0x47, 0x8f, 0x8f, 
        0x8f, 0x8f, 0x47, 0x63, 0x31, 0x1e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        },
        [3] = 
        {
        // 'Goblin4', 32x32px
        0x00, 0x7c, 0xc8, 0x90, 0x30, 0x20, 0x20, 0x10, 0x10, 0x18, 0x0c, 0x04, 0x02, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x02, 0x04, 0x0c, 0x18, 0x10, 0x10, 0x20, 0x20, 0x30, 0x90, 0xc8, 0x7c, 0x00, 
        0x00, 0x00, 0x00, 0x07, 0x09, 0x32, 0xe4, 0x00, 0x08, 0x10, 0xd0, 0xd0, 0xf0, 0xe0, 0x0c, 0x00, 
        0x00, 0x0c, 0xe0, 0xf0, 0xd0, 0xd0, 0x10, 0x08, 0x00, 0xe4, 0x32, 0x09, 0x07, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x08, 0xf8, 0xe0, 0xe1, 0xc1, 0xcc, 0xca, 0xd8, 
        0xd8, 0xca, 0xcc, 0xc1, 0xe1, 0xe0, 0xf8, 0x08, 0x0c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1e, 0x31, 0x63, 0x47, 0x8f, 0x8f, 
        0x8f, 0x8f, 0x47, 0x63, 0x31, 0x1e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        }
    };
    
    static const char PROGMEM goblin_text[] =
    {
        // 'Knob Goblin Text', 32x41px
        0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 
        0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x80, 0xc0, 0x20, 0x10, 0x00, 0xf0, 0x60, 0xc0, 0x80, 0xf0, 
        0x00, 0xe0, 0x10, 0x10, 0x10, 0xe0, 0x00, 0xf0, 0x50, 0x50, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x80, 0x80, 0x80, 0x83, 0x00, 0x00, 0x01, 0x82, 0x80, 0x83, 0x00, 0x00, 0x81, 0x83, 
        0x80, 0x01, 0x02, 0x82, 0x02, 0x01, 0x00, 0x03, 0x82, 0x02, 0x81, 0x00, 0x00, 0x00, 0x80, 0x00, 
        0x00, 0x0f, 0x1f, 0x10, 0x14, 0x14, 0x0d, 0x00, 0x0f, 0x10, 0x10, 0x10, 0x0f, 0x00, 0x1f, 0x12, 
        0x12, 0x0d, 0x00, 0x1f, 0x10, 0x10, 0x10, 0x00, 0x1f, 0x00, 0x1f, 0x03, 0x06, 0x0c, 0x1f, 0x00, 
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    void draw_animation(void) 
    {
        current_frame = (current_frame + 1) % 4;
        uint8_t frameIndex = abs((4 - 1) - current_frame);
        oled_write_raw_P(goblin[frameIndex], sizeof(goblin[frameIndex]));
        
        oled_set_cursor(0, 4);
        
        oled_write_raw_P(goblin_text, sizeof(goblin_text));
    }
    
    if (timer_elapsed32(keyevent_timer) > OLED_TIMEOUT)     
    {
        oled_off();
    }
    else
    {
        if(animation_timer == 0)
        {
            animation_timer = timer_read32();
            draw_animation();
        }        
        else if(timer_elapsed32(animation_timer) > frame_duration) 
        {
            animation_timer = timer_read32();
            draw_animation();
        }
    }      
}

// Update OLED graphics
__attribute__((weak)) void oled_task_user(void) 
{
	render_logo();

    oled_set_cursor(0, 9);

	switch (get_highest_layer(layer_state)) {
		case 0:
			oled_write_P(PSTR(" NUM\n"), false);
			break;

		case 1:
			oled_write_P(PSTR(" NAV\n"), false);
			break;

		case 5:
			oled_write_P(PSTR(" ???\n"), false);
			break;
	}
}
#endif