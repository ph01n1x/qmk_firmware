 /* Copyright 2020 Josef Adamcik
  * Modification for VIA support and RGB underglow by Jens Bonk-Wiltfang
  * 
  * This program is free software: you can redistribute it and/or modify 
  * it under the terms of the GNU General Public License as published by 
  * the Free Software Foundation, either version 2 of the License, or 
  * (at your option) any later version. 
  * 
  * This program is distributed in the hope that it will be useful, 
  * but WITHOUT ANY WARRANTY; without even the implied warranty of 
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
  * GNU General Public License for more details. 
  * 
  * You should have received a copy of the GNU General Public License 
  * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
  */ 

//Sets up what the OLED screens display.

#ifdef OLED_ENABLE


// Draw an image
// x is specified as pixels
// y is specified as OLED cursor line position
// Image must be of height of multiple of s
static void draw_image(const char *image, uint8_t x, uint8_t y, uint8_t width, uint8_t height, bool reverse)
{
    uint8_t maxLine = height / 8;
    uint16_t offset = 0;
    
    if (reverse)
    {
        for (uint8_t currentLine = 0; currentLine < maxLine; currentLine++)
        {
            offset = (y + currentLine) * OLED_DISPLAY_HEIGHT + x;
            
            for (uint8_t currentColumn = 0; currentColumn < width; currentColumn++)
            {
                char data = pgm_read_byte_near(image + currentLine * width + (width - currentColumn - 1));
                oled_write_raw_byte(data, offset + currentColumn);
            }
        }        
    }
    else
    {
        for (uint8_t currentLine = 0; currentLine < maxLine; currentLine++)
        {
            offset = (y + currentLine) * OLED_DISPLAY_HEIGHT + x;
            
            for (uint8_t currentColumn = 0; currentColumn < width; currentColumn++)
            {
                char data = pgm_read_byte_near(image + currentLine * width + currentColumn);
                oled_write_raw_byte(data, offset + currentColumn);
            }
        }
    }
}

// Initialize OLED screen
oled_rotation_t oled_init_user(oled_rotation_t rotation) 
{
    if (is_keyboard_master()) 
    {
        return OLED_ROTATION_90;
    }
    else
    {
        return OLED_ROTATION_270;
    }
    return rotation;
}

// Render the top logo
static void render_logo(bool reverse) 
{
    static const char PROGMEM my_logo[] = 
    {  
    // 'Phoenix', 32x32px
    0x00, 0x00, 0x00, 0x00, 0x80, 0xf0, 0xf8, 0x3c, 0x0c, 0x0e, 0x02, 0x32, 0xc2, 0xc4, 0xe0, 0xe0, 
    0xa0, 0xe0, 0xe4, 0xc2, 0x82, 0x02, 0x06, 0x0c, 0x3c, 0xf8, 0xf0, 0x80, 0x00, 0x00, 0x00, 0x00, 
    0x70, 0xfc, 0xe0, 0xc0, 0x9f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
    0xff, 0x01, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9f, 0xc0, 0xe0, 0xfc, 0x70, 
    0x00, 0x11, 0x63, 0xe7, 0xcf, 0xdf, 0xff, 0xf8, 0xf8, 0xf0, 0xf0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff, 
    0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xf0, 0xf0, 0xf8, 0xfc, 0xff, 0xdf, 0xcf, 0xe7, 0x63, 0x11, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x09, 0x09, 0x19, 0x19, 0x39, 0x3d, 0x7f, 0x7f, 0x7f, 0x7f, 
    0x7f, 0x7f, 0x7f, 0x7f, 0x3d, 0x39, 0x19, 0x19, 0x09, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00    
    };

    draw_image(my_logo, 16, 0, 32, 32, reverse);
}

// Render animation
#define FRAME_SIZE 128
#define FRAMES 2

uint32_t animation_timer = 0;
uint16_t frame_duration = 400;
uint8_t current_frame = 0;

uint8_t current_animation_runs = 0;

int8_t current_x = 0;
bool movement_reverse = false;

static void render_animation(int y) 
{    
    static const char PROGMEM sleep[2][FRAME_SIZE] = 
    {
        {
        // 'sleep1', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0xa8, 0x48, 0xa8, 0x18, 0x08, 0x00, 0x00, 0x00, 
        0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x80, 
        0x44, 0x84, 0x06, 0x05, 0x04, 0x80, 0x40, 0x20, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x20, 0x18, 0x04, 0x04, 0x02, 0x7a, 0x86, 0x01, 0x80, 
        0x80, 0x01, 0x03, 0x05, 0x07, 0x01, 0x00, 0x00, 0x80, 0x83, 0x45, 0xfa, 0x3c, 0xe0, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x31, 0x22, 0x24, 
        0x28, 0x29, 0x29, 0x29, 0x3a, 0x18, 0x1c, 0x39, 0x24, 0x24, 0x3a, 0x2d, 0x26, 0x31, 0x1f, 0x00,
        },
        {
        // 'sleep2', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x3a, 0x2a, 0x26, 0x22, 0x80, 0xc0, 
        0x80, 0x00, 0x24, 0x34, 0x2c, 0xe4, 0x60, 0x10, 0x70, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x38, 0x04, 0x02, 0x02, 0x01, 0x79, 0x87, 0x01, 0x80, 
        0x81, 0x83, 0x05, 0x05, 0x03, 0x01, 0x00, 0x00, 0x80, 0x43, 0x05, 0xfa, 0x3c, 0xe0, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x31, 0x22, 0x24, 
        0x28, 0x28, 0x29, 0x29, 0x3a, 0x18, 0x1c, 0x39, 0x24, 0x24, 0x3a, 0x2d, 0x26, 0x31, 0x1f, 0x00,
        }        
    };
    
    static const char PROGMEM mati[3][FRAME_SIZE] =
    {
        {
        // 'mati1', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30, 0x08, 0x10, 0x60, 0x80, 
        0x00, 0x80, 0x60, 0x10, 0x08, 0x30, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x40, 0x48, 0x48, 0x00, 0x01, 
        0x41, 0x01, 0x00, 0x48, 0x48, 0x40, 0x80, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x80, 0xe1, 0x12, 0x0a, 0x06, 0x00, 
        0x80, 0x00, 0x06, 0x0a, 0x12, 0xe1, 0x90, 0x48, 0x64, 0x92, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1f, 0x14, 0x14, 0x10, 0x10, 0x11, 0x1f, 0x10, 0x10, 0x18, 
        0x0f, 0x18, 0x10, 0x10, 0x1f, 0x11, 0x10, 0x10, 0x14, 0x14, 0x1f, 0x18, 0x00, 0x00, 0x00, 0x00,
        },      
        {        
        // 'mati2', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30, 0x08, 0x10, 0x60, 0x80, 
        0x00, 0x80, 0x60, 0x10, 0x08, 0x30, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x40, 0x40, 0x5c, 0x00, 0x01, 
        0x41, 0x01, 0x00, 0x5c, 0x40, 0x40, 0x80, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x80, 0xe1, 0x12, 0x0a, 0x06, 0x00, 
        0x80, 0x00, 0x06, 0x0a, 0x12, 0xe1, 0x80, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1f, 0x14, 0x14, 0x10, 0x10, 0x11, 0x1f, 0x10, 0x10, 0x18, 
        0x0f, 0x18, 0x10, 0x10, 0x1f, 0x11, 0x10, 0x10, 0x14, 0x14, 0x1f, 0x14, 0x14, 0x14, 0x14, 0x08, 
        }
    };

    static const char PROGMEM right[FRAMES][FRAME_SIZE] = 
    {
        {
        // 'right1', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x08, 0x10, 
        0x10, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x80, 0x60, 0x10, 0x88, 0x44, 0x22, 0x99, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
        0x30, 0xc0, 0x00, 0x00, 0x00, 0x13, 0x0c, 0x08, 0x08, 0x04, 0x04, 0x82, 0x39, 0x47, 0x80, 0x00, 
        0x03, 0x02, 0x01, 0x00, 0x00, 0x01, 0xc2, 0x3c, 0xb0, 0xc0, 0x00, 0x30, 0xd0, 0x50, 0x58, 0x28, 
        0x16, 0x09, 0x80, 0x80, 0x44, 0xc2, 0x62, 0x26, 0x44, 0x44, 0x40, 0x43, 0x40, 0x20, 0x17, 0x0c, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x03, 0x06, 0x07, 0x01, 0x01, 0x01, 
        0x07, 0x05, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        },
        {
        // 'right2', 32x32px
        0x38, 0x48, 0x88, 0x30, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0xf1, 0x0e, 0x00, 0x00, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04, 0x08, 0x08, 0x10, 
        0x20, 0x30, 0x0c, 0x06, 0x01, 0x01, 0x40, 0x40, 0x40, 0x40, 0x1d, 0x01, 0x02, 0x1c, 0xe0, 0x00, 
        0xf8, 0x88, 0xc6, 0x61, 0xa0, 0x60, 0x60, 0x50, 0x50, 0x30, 0x28, 0x68, 0x44, 0x40, 0x40, 0x40, 
        0x40, 0x40, 0xc0, 0xe0, 0xa0, 0x40, 0x80, 0x8c, 0x1c, 0x32, 0x22, 0x42, 0x82, 0x01, 0x00, 0x00, 
        0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00
        }        
    };

    static const char PROGMEM jump[2][FRAME_SIZE] =
    {
        {
        // 'upright2', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xd0, 0x10, 0x10, 0x10, 0x08, 
        0xec, 0x24, 0x4c, 0x4c, 0xc4, 0x14, 0x14, 0x14, 0x08, 0xf0, 0x20, 0x40, 0x40, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x70, 0x90, 0x10, 0x60, 0xa0, 0x10, 0x08, 0x04, 0x03, 0x0c, 0x10, 0x20, 
        0x03, 0x20, 0x00, 0x20, 0x00, 0x00, 0x08, 0x88, 0x8e, 0x47, 0x22, 0x33, 0x19, 0x0d, 0x07, 0x00, 
        0x80, 0x78, 0x04, 0x04, 0x03, 0x81, 0x86, 0x80, 0xc1, 0x22, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x80, 0x78, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x1f, 0x10, 0x08, 0x06, 0x01, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x80, 0x78, 0x04, 0x04, 0x04, 0x04, 
        0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        },
        {
        // 'dwright2', 32x32px
        0x00, 0x20, 0x50, 0x50, 0x50, 0x90, 0x10, 0x20, 0x40, 0x90, 0xa8, 0xa8, 0x68, 0x08, 0x88, 0x48, 
        0x38, 0x90, 0xd0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x20, 0x40, 0x80, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 
        0x01, 0x80, 0x40, 0x41, 0x22, 0x1c, 0x08, 0x04, 0x1c, 0x30, 0xe0, 0x10, 0x10, 0x88, 0x78, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x0c, 0x30, 0x40, 0x80, 
        0x20, 0x4b, 0x88, 0x88, 0x10, 0x00, 0x00, 0x38, 0x00, 0x00, 0x80, 0x38, 0x80, 0xff, 0x10, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x01, 0x02, 0x0c, 0x10, 0x21, 0x21, 0x3f, 0x03, 0x02, 0x06, 0x1a, 0x21, 0x23, 0x1c, 0x00, 0x00,
        }
    };

    static const char PROGMEM rtogil[FRAMES][FRAME_SIZE] = 
    {
        {
        // 'rtogi1', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xc0, 0x20, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x0f, 0x90, 0x10, 0x20, 0xf0, 0xf8, 0xf8, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 
        0x48, 0x47, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0xc7, 0xc4, 0x62, 0x23, 0x10, 0x3f, 
        0x80, 0x40, 0x20, 0x10, 0x88, 0xcc, 0x43, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc0, 
        0x80, 0x80, 0xc0, 0xe1, 0xbe, 0x98, 0x88, 0x0c, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x06, 0x04, 0x04, 0x04, 0x04, 
        0x05, 0x04, 0x04, 0x04, 0x07, 0x07, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        },
        {
        // 'rtogi2', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xc0, 0x20, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x1f, 0xa0, 0x20, 0x40, 0x80, 0x00, 0xf0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 
        0x48, 0x47, 0x88, 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x28, 0x6b, 0x40, 0xa0, 0x99, 0x86, 0xff, 
        0x0f, 0x11, 0x22, 0x44, 0x48, 0x4c, 0x43, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc0, 
        0x80, 0x80, 0xc0, 0xe1, 0xbe, 0x98, 0x88, 0x0c, 0x04, 0x06, 0x06, 0x06, 0x0a, 0x0a, 0x06, 0x01, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x06, 0x04, 0x04, 0x04, 0x04, 
        0x05, 0x04, 0x04, 0x04, 0x07, 0x04, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        }
    };

    void draw_animation(void) 
    {
        // First animation after sleep will always be normal
        if (current_animation != target_animation)
        {
            if (current_animation == ANIMATION_SLEEP)
            {
                target_animation = ANIMATION_NORMAL;
            }
            
            current_animation = target_animation; 
            current_frame = 0;
            current_animation_runs = 0;
        }
        
        // Animation switch eventually to sleep
        if (current_animation !=  ANIMATION_SLEEP && timer_elapsed32(keyevent_timer) > 10000)
        {
            if (timer_elapsed32(keyevent_timer) > 26000)
            {
                if (current_animation != ANIMATION_SLEEP)
                {
                    current_frame = 0;
                }
                current_animation = ANIMATION_SLEEP;
                target_animation = current_animation;
            }                
            else if (timer_elapsed32(keyevent_timer) > 10000)
            {
                if (current_animation != ANIMATION_NORMAL)
                {
                    current_frame = 0;
                }
                current_animation = ANIMATION_NORMAL;
                target_animation = current_animation;
            }  
        }
        
        // Update the frame durations
        if (current_animation == ANIMATION_NORMAL)
        {
            frame_duration = 800;
        }
        else if (current_animation == ANIMATION_RUN || current_animation == ANIMATION_JUMP)
        {
            frame_duration = 400;
        }
        else
        {
            frame_duration = 400;
        }
        
        // Draw the animation
        bool toggleMovement = false;
        uint8_t targetY = y;
        uint8_t frameIndex = 0;
        const char* image = 0;
        switch (current_animation)
        {
            case ANIMATION_NORMAL:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                
                if (frameIndex == 0)
                {
                    image = mati[0];
                }
                else 
                {
                    image = mati[1];
                }
                break;
    
             case ANIMATION_RUN:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                image = right[frameIndex];
                break;

              case ANIMATION_JUMP:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                image = jump[frameIndex];
                
                if (frameIndex == 0)
                {
                    targetY = y - 2;
                }
                else
                {
                    targetY = y - 1;
                }
                
                // Jump goes back to run
                if (target_animation_runs > 0)
                {
                    if (frameIndex == 1)
                    {
                        current_animation_runs++;
                    }
                
                    if (current_animation_runs >= target_animation_runs)
                    {
                        target_animation = ANIMATION_RUN;
                        target_animation_runs = 0;
                    }
                }
                break;

            case ANIMATION_RTOGIL:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                image = rtogil[frameIndex];
                
                if (target_animation_runs > 0)
                {
                    if (frameIndex == 1)
                    {
                        current_animation_runs++;
                    }
                
                    if (current_animation_runs >= target_animation_runs)
                    {
                        target_animation = ANIMATION_NORMAL;
                        target_animation_runs = 0;
                    }
                }
                break;

            default:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                image = sleep[frameIndex];
                break;
        }
        
        // Move the position if running or jumping
        if (current_animation == ANIMATION_RUN
            || current_animation == ANIMATION_JUMP)
        {
            if (movement_reverse)
            {
                current_x -= 3;
            }
            else
            {
                current_x += 3;
            }
            
            if (movement_reverse && current_x <= 0)
            {
                toggleMovement = true;
                current_animation = ANIMATION_RTOGIL;
                image = rtogil[frameIndex];
            }
            else if (!movement_reverse && current_x >= 31)
            {
                toggleMovement = true;
                current_animation = ANIMATION_RTOGIL;
                image = rtogil[frameIndex];
            }
            
            if (current_x < 0)
            {
                current_x = 0;
            }
            else if (current_x > 31)
            {
                current_x = 31;
            }
        }
        
        if (image != 0)
        {
            for (uint8_t py = (y - 2); py < (y - 2) + 6; py++)
            {
                for (uint8_t px = 0; px < OLED_DISPLAY_HEIGHT; px++)
                {
                    uint16_t offset = py * OLED_DISPLAY_HEIGHT + px;
                    oled_write_raw_byte(0x00, offset);
                }
            }
            
            draw_image(image, current_x, targetY, 32, 32, movement_reverse);
        }
        
        if (toggleMovement)
        {
            movement_reverse = !movement_reverse;
        }
    }
    
    if (timer_elapsed32(keyevent_timer) > OLED_TIMEOUT)     
    {
        oled_off();
    }
    else
    {        
        if(animation_timer == 0)
        {
            animation_timer = timer_read32();
            draw_animation();
        }        
        else if(timer_elapsed32(animation_timer) > frame_duration) 
        {
            animation_timer = timer_read32();
            draw_animation();
        }
    }
}

// Display layer
static void display_layer(void)
{
    // Layer information
    switch (get_highest_layer(layer_state)) {
        case _DEFAULT:
            oled_write_ln_P(PSTR("Meow"), false);
            break;
        case _LOWER:
            oled_write_ln_P(PSTR("Purr"), false);
            break;
        case _RAISE:
            oled_write_ln_P(PSTR("Gao!"), false);
            break;
        default:
            oled_write_ln_P(PSTR("Hiss"), false);
    }
}

// Display keyboard status
static void display_status(void) 
{
    // LED state
    led_t led_usb_state = host_keyboard_led_state();
    oled_write_ln_P(PSTR("CAP"), led_usb_state.caps_lock);
    oled_write_ln_P(PSTR("SCR"), led_usb_state.scroll_lock);
    oled_write_ln_P(PSTR("NUM"), led_usb_state.num_lock);

    oled_write_ln_P(PSTR(""), false);
}

// OLED display
void oled_task_user(void) 
{
    if (is_keyboard_master()) 
    {
        render_logo(false);
        
        oled_set_cursor(0, 5);

        display_layer();
                
        render_animation(8);

        // Right encoder mode
        oled_set_cursor(0, 14);
        switch (encoder2_mode)
        {
            case ENCODER_WIN:
                oled_write("Win ", false);
                break;
                
            case ENCODER_TAB:
                oled_write("Tab ", false);
                break;

            case ENCODER_PAGE:
                oled_write("Page", false);
                break;
                
            case ENCODER_BOOKMARK:
                oled_write("BM  ", false);
                break;
             
             default:
                oled_write("      ", false);
                break;
        }      
    } 
    else 
    {
        render_logo(true);
        
        oled_set_cursor(0, 5);
        
        display_status();
    }
}

#endif