 /* Copyright 2020 Josef Adamcik
  * Modification for VIA support and RGB underglow by Jens Bonk-Wiltfang
  * 
  * This program is free software: you can redistribute it and/or modify 
  * it under the terms of the GNU General Public License as published by 
  * the Free Software Foundation, either version 2 of the License, or 
  * (at your option) any later version. 
  * 
  * This program is distributed in the hope that it will be useful, 
  * but WITHOUT ANY WARRANTY; without even the implied warranty of 
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
  * GNU General Public License for more details. 
  * 
  * You should have received a copy of the GNU General Public License 
  * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
  */ 

//Sets up what the OLED screens display.

#ifdef OLED_ENABLE

// Initialize OLED screen
oled_rotation_t oled_init_user(oled_rotation_t rotation) 
{
    if (is_keyboard_master()) 
    {
        return OLED_ROTATION_270;
    }
    else
    {
        return OLED_ROTATION_270;
    }
    return rotation;
}

// Render the top logo
static void render_logo(void) 
{
    static const char PROGMEM my_logo[] = 
    {
    // 'Phoenix', 32x32px
    0x00, 0x00, 0x00, 0x00, 0x80, 0xf0, 0xf8, 0x3c, 0x0c, 0x0e, 0x02, 0x32, 0xc2, 0xc4, 0xe0, 0xe0, 
    0xa0, 0xe0, 0xe4, 0xc2, 0x82, 0x02, 0x06, 0x0c, 0x3c, 0xf8, 0xf0, 0x80, 0x00, 0x00, 0x00, 0x00, 
    0x70, 0xfc, 0xe0, 0xc0, 0x9f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
    0xff, 0x01, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9f, 0xc0, 0xe0, 0xfc, 0x70, 
    0x00, 0x11, 0x63, 0xe7, 0xcf, 0xdf, 0xff, 0xf8, 0xf8, 0xf0, 0xf0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff, 
    0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xf0, 0xf0, 0xf8, 0xfc, 0xff, 0xdf, 0xcf, 0xe7, 0x63, 0x11, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x09, 0x09, 0x19, 0x19, 0x39, 0x3d, 0x7f, 0x7f, 0x7f, 0x7f, 
    0x7f, 0x7f, 0x7f, 0x7f, 0x3d, 0x39, 0x19, 0x19, 0x09, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    oled_write_raw_P(my_logo, sizeof(my_logo));
}

// Render animation
#define FRAME_SIZE 128
#define FRAMES 2

uint32_t animation_timer = 0;
uint16_t frame_duration = 400;
uint8_t current_frame = 0;

uint8_t current_animation_runs = 0;

static void render_animation(int y) 
{    
    static const char PROGMEM sleep[2][FRAME_SIZE] = 
    {
        {
        // 'sleep1', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0xa8, 0x48, 0xa8, 0x18, 0x08, 0x00, 0x00, 0x00, 
        0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x80, 
        0x44, 0x84, 0x06, 0x05, 0x04, 0x80, 0x40, 0x20, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x20, 0x18, 0x04, 0x04, 0x02, 0x7a, 0x86, 0x01, 0x80, 
        0x80, 0x01, 0x03, 0x05, 0x07, 0x01, 0x00, 0x00, 0x80, 0x83, 0x45, 0xfa, 0x3c, 0xe0, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x31, 0x22, 0x24, 
        0x28, 0x29, 0x29, 0x29, 0x3a, 0x18, 0x1c, 0x39, 0x24, 0x24, 0x3a, 0x2d, 0x26, 0x31, 0x1f, 0x00,
        },
        {
        // 'sleep2', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x3a, 0x2a, 0x26, 0x22, 0x80, 0xc0, 
        0x80, 0x00, 0x24, 0x34, 0x2c, 0xe4, 0x60, 0x10, 0x70, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x38, 0x04, 0x02, 0x02, 0x01, 0x79, 0x87, 0x01, 0x80, 
        0x81, 0x83, 0x05, 0x05, 0x03, 0x01, 0x00, 0x00, 0x80, 0x43, 0x05, 0xfa, 0x3c, 0xe0, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x31, 0x22, 0x24, 
        0x28, 0x28, 0x29, 0x29, 0x3a, 0x18, 0x1c, 0x39, 0x24, 0x24, 0x3a, 0x2d, 0x26, 0x31, 0x1f, 0x00,
        }        
    };
    
    static const char PROGMEM mati[3][FRAME_SIZE] =
    {
        {
        // 'mati1', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30, 0x08, 0x10, 0x60, 0x80, 
        0x00, 0x80, 0x60, 0x10, 0x08, 0x30, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x40, 0x48, 0x48, 0x00, 0x01, 
        0x41, 0x01, 0x00, 0x48, 0x48, 0x40, 0x80, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x80, 0xe1, 0x12, 0x0a, 0x06, 0x00, 
        0x80, 0x00, 0x06, 0x0a, 0x12, 0xe1, 0x90, 0x48, 0x64, 0x92, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1f, 0x14, 0x14, 0x10, 0x10, 0x11, 0x1f, 0x10, 0x10, 0x18, 
        0x0f, 0x18, 0x10, 0x10, 0x1f, 0x11, 0x10, 0x10, 0x14, 0x14, 0x1f, 0x18, 0x00, 0x00, 0x00, 0x00,
        },      
        {        
        // 'mati2', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30, 0x08, 0x10, 0x60, 0x80, 
        0x00, 0x80, 0x60, 0x10, 0x08, 0x30, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x40, 0x40, 0x5c, 0x00, 0x01, 
        0x41, 0x01, 0x00, 0x5c, 0x40, 0x40, 0x80, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x80, 0xe1, 0x12, 0x0a, 0x06, 0x00, 
        0x80, 0x00, 0x06, 0x0a, 0x12, 0xe1, 0x80, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1f, 0x14, 0x14, 0x10, 0x10, 0x11, 0x1f, 0x10, 0x10, 0x18, 
        0x0f, 0x18, 0x10, 0x10, 0x1f, 0x11, 0x10, 0x10, 0x14, 0x14, 0x1f, 0x14, 0x14, 0x14, 0x14, 0x08, 
        }
    };

    static const char PROGMEM right[FRAMES][FRAME_SIZE] = 
    {
        {
        // 'right1', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x08, 0x10, 
        0x10, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x80, 0x60, 0x10, 0x88, 0x44, 0x22, 0x99, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
        0x30, 0xc0, 0x00, 0x00, 0x00, 0x13, 0x0c, 0x08, 0x08, 0x04, 0x04, 0x82, 0x39, 0x47, 0x80, 0x00, 
        0x03, 0x02, 0x01, 0x00, 0x00, 0x01, 0xc2, 0x3c, 0xb0, 0xc0, 0x00, 0x30, 0xd0, 0x50, 0x58, 0x28, 
        0x16, 0x09, 0x80, 0x80, 0x44, 0xc2, 0x62, 0x26, 0x44, 0x44, 0x40, 0x43, 0x40, 0x20, 0x17, 0x0c, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x03, 0x06, 0x07, 0x01, 0x01, 0x01, 
        0x07, 0x05, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        },
        {
        // 'right2', 32x32px
        0x38, 0x48, 0x88, 0x30, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0xf1, 0x0e, 0x00, 0x00, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04, 0x08, 0x08, 0x10, 
        0x20, 0x30, 0x0c, 0x06, 0x01, 0x01, 0x40, 0x40, 0x40, 0x40, 0x1d, 0x01, 0x02, 0x1c, 0xe0, 0x00, 
        0xf8, 0x88, 0xc6, 0x61, 0xa0, 0x60, 0x60, 0x50, 0x50, 0x30, 0x28, 0x68, 0x44, 0x40, 0x40, 0x40, 
        0x40, 0x40, 0xc0, 0xe0, 0xa0, 0x40, 0x80, 0x8c, 0x1c, 0x32, 0x22, 0x42, 0x82, 0x01, 0x00, 0x00, 
        0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00
        }        
    };

    static const char PROGMEM jump[2][FRAME_SIZE] =
    {
        {
        // 'upright2', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xd0, 0x10, 0x10, 0x10, 0x08, 
        0xec, 0x24, 0x4c, 0x4c, 0xc4, 0x14, 0x14, 0x14, 0x08, 0xf0, 0x20, 0x40, 0x40, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x70, 0x90, 0x10, 0x60, 0xa0, 0x10, 0x08, 0x04, 0x03, 0x0c, 0x10, 0x20, 
        0x03, 0x20, 0x00, 0x20, 0x00, 0x00, 0x08, 0x88, 0x8e, 0x47, 0x22, 0x33, 0x19, 0x0d, 0x07, 0x00, 
        0x80, 0x78, 0x04, 0x04, 0x03, 0x81, 0x86, 0x80, 0xc1, 0x22, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x80, 0x78, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x1f, 0x10, 0x08, 0x06, 0x01, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x80, 0x78, 0x04, 0x04, 0x04, 0x04, 
        0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        },
        {
        // 'dwright2', 32x32px
        0x00, 0x20, 0x50, 0x50, 0x50, 0x90, 0x10, 0x20, 0x40, 0x90, 0xa8, 0xa8, 0x68, 0x08, 0x88, 0x48, 
        0x38, 0x90, 0xd0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x20, 0x40, 0x80, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 
        0x01, 0x80, 0x40, 0x41, 0x22, 0x1c, 0x08, 0x04, 0x1c, 0x30, 0xe0, 0x10, 0x10, 0x88, 0x78, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x0c, 0x30, 0x40, 0x80, 
        0x20, 0x4b, 0x88, 0x88, 0x10, 0x00, 0x00, 0x38, 0x00, 0x00, 0x80, 0x38, 0x80, 0xff, 0x10, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x01, 0x02, 0x0c, 0x10, 0x21, 0x21, 0x3f, 0x03, 0x02, 0x06, 0x1a, 0x21, 0x23, 0x1c, 0x00, 0x00,
        }
    };

    static const char PROGMEM rtogil[FRAMES][FRAME_SIZE] = 
    {
        {
        // 'rtogi1', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xc0, 0x20, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x0f, 0x90, 0x10, 0x20, 0xf0, 0xf8, 0xf8, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 
        0x48, 0x47, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0xc7, 0xc4, 0x62, 0x23, 0x10, 0x3f, 
        0x80, 0x40, 0x20, 0x10, 0x88, 0xcc, 0x43, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc0, 
        0x80, 0x80, 0xc0, 0xe1, 0xbe, 0x98, 0x88, 0x0c, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x06, 0x04, 0x04, 0x04, 0x04, 
        0x05, 0x04, 0x04, 0x04, 0x07, 0x07, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        },
        {
        // 'rtogi2', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xc0, 0x20, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x1f, 0xa0, 0x20, 0x40, 0x80, 0x00, 0xf0, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 
        0x48, 0x47, 0x88, 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x28, 0x6b, 0x40, 0xa0, 0x99, 0x86, 0xff, 
        0x0f, 0x11, 0x22, 0x44, 0x48, 0x4c, 0x43, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc0, 
        0x80, 0x80, 0xc0, 0xe1, 0xbe, 0x98, 0x88, 0x0c, 0x04, 0x06, 0x06, 0x06, 0x0a, 0x0a, 0x06, 0x01, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x06, 0x04, 0x04, 0x04, 0x04, 
        0x05, 0x04, 0x04, 0x04, 0x07, 0x04, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        }
    };

    void draw_animation(void) 
    {
        // First animation afther sleep will always be normal
        if (current_animation != target_animation)
        {
            // Clear old frame
            if (current_animation == ANIMATION_JUMP)
            {
                for (uint8_t py = (y - 2) * 8; py < y * 8 + 32; py++)
                {
                    for (uint8_t px = 0; px < 32; px++)
                    {
                        oled_write_pixel(px, py, false);
                    }
                }
            }

            if (current_animation == ANIMATION_SLEEP)
            {
                target_animation = ANIMATION_NORMAL;
            }
            
            current_animation = target_animation; 
            current_frame = 0;
            current_animation_runs = 0;
        }
        
        // Animation switch eventually to sleep
        if (current_animation !=  ANIMATION_SLEEP && timer_elapsed32(keyevent_timer) > 10000)
        {
            if (timer_elapsed32(keyevent_timer) > 26000)
            {
                if (current_animation != ANIMATION_SLEEP)
                {
                    current_frame = 0;
                }
                current_animation = ANIMATION_SLEEP;
                target_animation = current_animation;
            }                
            else if (timer_elapsed32(keyevent_timer) > 10000)
            {
                if (current_animation != ANIMATION_NORMAL)
                {
                    current_frame = 0;
                }
                current_animation = ANIMATION_NORMAL;
                target_animation = current_animation;
            }  
        }
        
        // Update the frame durations
        if (current_animation == ANIMATION_NORMAL)
        {
            frame_duration = 800;
        }
        else if (current_animation == ANIMATION_RUN || current_animation == ANIMATION_JUMP)
        {
            frame_duration = 400;
        }
        else
        {
            frame_duration = 400;
        }

        oled_set_cursor(0, y); 
        
        // Draw the animation 
        uint8_t frameIndex = 0;
        switch (current_animation)
        {
            case ANIMATION_NORMAL:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                
                if (frameIndex == 0)
                {
                    oled_write_raw_P(mati[0], sizeof(mati[0]));
                }
                else 
                {
                    oled_write_raw_P(mati[1], sizeof(mati[1]));
                }
                break;
    
             case ANIMATION_RUN:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                oled_write_raw_P(right[frameIndex], sizeof(right[frameIndex]));
                break;

              case ANIMATION_JUMP:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                
                // Clear old frame
                for (uint8_t py = (y - 2) * 8; py < y * 8 + 32; py++)
                {
                    for (uint8_t px = 0; px < 32; px++)
                    {
                        oled_write_pixel(px, py, false);
                    }
                }  
                
                if (frameIndex == 0)
                {
                    oled_set_cursor(0, y - 2);
                }
                else
                {                                  
                    oled_set_cursor(0, y - 1);
                }
                
                oled_write_raw_P(jump[frameIndex], sizeof(jump[frameIndex]));
                
                // Jump goes back to run
                if (target_animation_runs > 0)
                {
                    if (frameIndex == 1)
                    {
                        current_animation_runs++;
                    }
                
                    if (current_animation_runs >= target_animation_runs)
                    {
                        target_animation = ANIMATION_RUN;
                        target_animation_runs = 0;
                    }
                }
                break;

            case ANIMATION_RTOGIL:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                oled_write_raw_P(rtogil[frameIndex], sizeof(rtogil[frameIndex]));
                
                if (target_animation_runs > 0)
                {
                    if (frameIndex == 1)
                    {
                        current_animation_runs++;
                    }
                
                    if (current_animation_runs >= target_animation_runs)
                    {
                        target_animation = ANIMATION_NORMAL;
                        target_animation_runs = 0;
                    }
                }
                break;

            default:
                current_frame = (current_frame + 1) % FRAMES;
                frameIndex = abs((FRAMES - 1) - current_frame);
                oled_write_raw_P(sleep[frameIndex], sizeof(sleep[frameIndex]));
                break;
        }
    }
    
    if (timer_elapsed32(keyevent_timer) > OLED_TIMEOUT)     
    {
        oled_off();
    }
    else
    {        
        if(animation_timer == 0)
        {
            animation_timer = timer_read32();
            draw_animation();
        }        
        else if(timer_elapsed32(animation_timer) > frame_duration) 
        {
            animation_timer = timer_read32();
            draw_animation();
        }
    }
}

// Display layer
static void display_layer(void)
{
    // Layer information
    switch (get_highest_layer(layer_state)) {
        case _DEFAULT:
            oled_write_ln_P(PSTR("Meow"), false);
            break;
        case _LOWER:
            oled_write_ln_P(PSTR("Purr"), false);
            break;
        case _RAISE:
            oled_write_ln_P(PSTR("Gao!"), false);
            break;
        default:
            oled_write_ln_P(PSTR("Hiss"), false);
    }
}

// Display keyboard status
static void display_status(void) 
{
    // LED state
    led_t led_usb_state = host_keyboard_led_state();
    oled_write_ln_P(PSTR("CAP"), led_usb_state.caps_lock);
    oled_write_ln_P(PSTR("SCR"), led_usb_state.scroll_lock);
    oled_write_ln_P(PSTR("NUM"), led_usb_state.num_lock);

    oled_write_ln_P(PSTR(""), false);
}

// OLED display
void oled_task_user(void) 
{
    if (is_keyboard_master()) 
    {
        render_logo();
        
        oled_set_cursor(0, 5);

        display_layer();
                
        render_animation(8);

        // Right encoder mode
        oled_set_cursor(0, 14);
        switch (encoder2_mode)
        {
            case ENCODER_WIN:
                oled_write("Win ", false);
                break;
                
            case ENCODER_TAB:
                oled_write("Tab ", false);
                break;

            case ENCODER_PAGE:
                oled_write("Page", false);
                break;
                
            case ENCODER_BOOKMARK:
                oled_write("BM  ", false);
                break;
             
             default:
                oled_write("      ", false);
                break;
        }      
    } 
    else 
    {
        render_logo();
        
        oled_set_cursor(0, 5);
        
        display_status();
    }
}

#endif